import type { FormatOptions } from "../types";
import Params from './Params';
import { type Token } from './token';
import AsTokenFactory from './AsTokenFactory';
import { type Statement } from './Parser';
/** Formats single SQL statement */
export default class StatementFormatter {
    private cfg;
    private indentation;
    private inlineBlock;
    private aliasAs;
    private params;
    private asTokenFactory;
    private query;
    private currentNewline;
    private previousReservedToken;
    private previousCommandToken;
    private tokens;
    private index;
    constructor(cfg: FormatOptions, params: Params, asTokenFactory: AsTokenFactory);
    format(statement: Statement): string;
    private formatToken;
    /**
     * Formats word tokens + any potential AS tokens for aliases
     */
    private formatWord;
    /**
     * Checks if a newline should currently be inserted
     */
    private checkNewline;
    private inlineWidth;
    /**
     * Counts comma-separated clauses (doesn't count commas inside blocks)
     * Note: There's always at least one clause.
     */
    private countClauses;
    /** get all tokens between current token and next Reserved Command or query end */
    private tokensUntilNextCommandOrQueryEnd;
    /** Formats a line comment onto query */
    private formatLineComment;
    /** Formats a block comment onto query */
    private formatBlockComment;
    /** Aligns comment to current indentation level */
    private indentComment;
    /**
     * Formats a Reserved Command onto query, increasing indentation level where necessary
     */
    private formatCommand;
    /**
     * Formats a Reserved Binary Command onto query, joining neighbouring tokens
     */
    private formatBinaryCommand;
    /**
     * Formats a Reserved Keyword onto query, skipping AS if disabled
     */
    private formatKeyword;
    /**
     * Formats a Reserved Dependent Clause token onto query, supporting the keyword that precedes it
     */
    private formatDependentClause;
    private formatJoinCondition;
    /**
     * Formats an Operator onto query, following rules for specific characters
     */
    private formatOperator;
    /**
     * Formats a Logical Operator onto query, joining boolean conditions
     */
    private formatLogicalOperator;
    private formatBlockStart;
    private formatBlockEnd;
    private formatCaseStart;
    private formatCaseEnd;
    private formatMultilineBlockEnd;
    /**
     * Formats a parameter placeholder item onto query, to be replaced with the value of the placeholder
     */
    private formatParameter;
    /**
     * Formats a comma Operator onto query, ending line unless in an Inline Block
     */
    private formatComma;
    private formatQuerySeparator;
    private show;
    private isTabularToken;
    private showToken;
    /** Returns the latest encountered reserved keyword token */
    getPreviousReservedToken(): Token;
    /** True when currently within SELECT command */
    isWithinSelect(): boolean;
    /** Fetches nth previous token from the token stream */
    tokenLookBehind(n?: number): Token;
    /** Fetches nth next token from the token stream */
    tokenLookAhead(n?: number): Token;
}

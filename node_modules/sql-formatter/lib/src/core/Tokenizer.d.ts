import * as regexFactory from './regexFactory';
import { type Token } from './token';
export declare const WHITESPACE_REGEX: RegExp;
/** Struct that defines how a SQL language can be broken into tokens */
interface TokenizerOptions {
    reservedCommands: string[];
    reservedLogicalOperators?: string[];
    reservedDependentClauses: string[];
    reservedBinaryCommands: string[];
    reservedJoinConditions?: string[];
    reservedKeywords: string[];
    stringTypes: regexFactory.QuoteType[];
    identTypes: regexFactory.QuoteType[];
    variableTypes?: regexFactory.VariableType[];
    blockStart?: string[];
    blockEnd?: string[];
    positionalParams?: boolean;
    numberedParamTypes?: ('?' | ':' | '$')[];
    namedParamTypes?: (':' | '@' | '$')[];
    quotedParamTypes?: (':' | '@' | '$')[];
    lineCommentTypes?: string[];
    identChars?: regexFactory.IdentChars;
    paramChars?: regexFactory.IdentChars;
    operators?: string[];
    preprocess?: (tokens: Token[]) => Token[];
}
/** Converts SQL language string into a token stream */
export default class Tokenizer {
    private REGEX_MAP;
    private quotedIdentRegex;
    private paramPatterns;
    private preprocess;
    constructor(cfg: TokenizerOptions);
    private excludePatternsWithoutRegexes;
    /**
     * Takes a SQL string and breaks it into tokens.
     * Each token is an object with type and value.
     *
     * @param {string} input - The SQL string
     * @returns {Token[]} output token stream
     */
    tokenize(input: string): Token[];
    /** Matches preceding whitespace if present */
    private getWhitespace;
    /** Attempts to match next token from input string, tests RegExp patterns in decreasing priority */
    private getNextToken;
    /**
     * Attempts to match a placeholder token pattern
     * @return {Token | undefined} - The placeholder token if found, otherwise undefined
     */
    private matchPlaceholderToken;
    private getEscapedPlaceholderKey;
    private matchQuotedIdentToken;
    /**
     * Attempts to match a Reserved word token pattern, avoiding edge cases of Reserved words within string tokens
     * @return {Token | undefined} - The Reserved word token if found, otherwise undefined
     */
    private matchReservedWordToken;
    private matchReservedToken;
    private matchToken;
    /**
     * Attempts to match RegExp from head of input, returning undefined if not found
     * @param {string} _.input - The string to match
     * @param {TokenType} _.type - The type of token to match against
     * @param {RegExp} _.regex - The regex to match
     * @return {Token | undefined} - The matched token if found, otherwise undefined
     */
    private match;
}
export {};

{"version":3,"sources":["../../src/core/formatAliasPositions.ts"],"names":["formatAliasPositions","query","lines","split","newQuery","i","length","match","aliasLines","push","splitLines","map","line","matches","precedingText","as","alias","aliasMaxLength","replace","repeat","join"],"mappings":"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","sourcesContent":["import { maxLength } from 'src/utils';\n\n/**\n * Handles select alias placement - tabulates if enabled\n */\nexport default function formatAliasPositions(query: string): string {\n  const lines = query.split('\\n');\n\n  let newQuery: string[] = [];\n  for (let i = 0; i < lines.length; i++) {\n    // find SELECT rows with trailing comma, if no comma (only one row) - no-op\n    if (lines[i].match(/^\\s*SELECT/i)) {\n      let aliasLines: string[] = [];\n      if (lines[i].match(/.*,$/)) {\n        aliasLines = [lines[i]]; // add select to aliasLines in case of tabular formats\n      } else {\n        newQuery.push(lines[i]); // add select to new query\n        if (lines[i].match(/^\\s*SELECT\\s+.+(?!,$)/i)) {\n          continue;\n        }\n        aliasLines.push(lines[++i]);\n      }\n\n      // get all lines in SELECT clause\n      while (lines[i++].match(/.*,$/)) {\n        aliasLines.push(lines[i]);\n      }\n\n      // break lines into alias with optional AS, and all preceding text\n      const splitLines = aliasLines\n        .map(line => ({ line, matches: line.match(/(^.*?\\S) (AS )?(\\S+,?$)/i) }))\n        .map(({ line, matches }) => {\n          if (!matches) {\n            return { precedingText: line };\n          }\n          return {\n            precedingText: matches[1],\n            as: matches[2],\n            alias: matches[3],\n          };\n        });\n\n      // get longest of precedingText, trim trailing comma for non-alias columns\n      const aliasMaxLength = maxLength(\n        splitLines.map(({ precedingText }) => precedingText.replace(/\\s*,\\s*$/, ''))\n      );\n      // re-construct line, aligning by inserting space before AS or alias\n      aliasLines = splitLines.map(\n        ({ precedingText, as, alias }) =>\n          precedingText +\n          (alias ? ' '.repeat(aliasMaxLength - precedingText.length + 1) + (as ?? '') + alias : '')\n      );\n      newQuery = [...newQuery, ...aliasLines];\n    }\n    newQuery.push(lines[i]);\n  }\n\n  return newQuery.join('\\n');\n}\n"],"file":"formatAliasPositions.js"}
{"version":3,"sources":["../../src/core/Formatter.ts"],"names":["Formatter","cfg","params","Params","Error","cls","constructor","cachedTokenizer","tokenizer","query","tokens","tokenize","ast","Parser","parse","formattedQuery","formatAst","finalQuery","postFormat","trimEnd","statements","asTokenFactory","AsTokenFactory","keywordCase","map","stat","StatementFormatter","format","join","repeat","linesBetweenQueries","tabulateAlias","commaPosition"],"mappings":";;;;;;;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AAEA;;;;;;;;;;;;AAEA;IACqBA,S;AAInB,qBAAYC,GAAZ,EAAgC;AAAA;;AAAA;;AAAA;;AAC9B,SAAKA,GAAL,GAAWA,GAAX;AACA,SAAKC,MAAL,GAAc,IAAIC,kBAAJ,CAAW,KAAKF,GAAL,CAASC,MAApB,CAAd;AACD;AAED;AACF;AACA;;;;;WACE,qBAAiC;AAC/B,YAAM,IAAIE,KAAJ,CAAU,yCAAV,CAAN;AACD,K,CAED;AACA;AACA;;;;WACA,2BAAqC;AACnC,UAAMC,GAA+C,GAAG,KAAKC,WAA7D;;AACA,UAAI,CAACD,GAAG,CAACE,eAAT,EAA0B;AACxBF,QAAAA,GAAG,CAACE,eAAJ,GAAsB,KAAKC,SAAL,EAAtB;AACD;;AACD,aAAOH,GAAG,CAACE,eAAX;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,gBAAcE,KAAd,EAAqC;AACnC,UAAMC,MAAM,GAAG,KAAKH,eAAL,GAAuBI,QAAvB,CAAgCF,KAAhC,CAAf;AACA,UAAMG,GAAG,GAAG,IAAIC,kBAAJ,CAAWH,MAAX,EAAmBI,KAAnB,EAAZ;AACA,UAAMC,cAAc,GAAG,KAAKC,SAAL,CAAeJ,GAAf,EAAoBF,MAApB,CAAvB;AACA,UAAMO,UAAU,GAAG,KAAKC,UAAL,CAAgBH,cAAhB,CAAnB;AAEA,aAAOE,UAAU,CAACE,OAAX,EAAP;AACD;;;WAED,mBAAkBC,UAAlB,EAA2CV,MAA3C,EAAoE;AAAA;;AAClE,UAAMW,cAAc,GAAG,IAAIC,0BAAJ,CAAmB,KAAKrB,GAAL,CAASsB,WAA5B,EAAyCb,MAAzC,CAAvB;AAEA,aAAOU,UAAU,CACdI,GADI,CACA,UAAAC,IAAI;AAAA,eAAI,IAAIC,8BAAJ,CAAuB,KAAI,CAACzB,GAA5B,EAAiC,KAAI,CAACC,MAAtC,EAA8CmB,cAA9C,EAA8DM,MAA9D,CAAqEF,IAArE,CAAJ;AAAA,OADJ,EAEJG,IAFI,CAEC,KAAKC,MAAL,CAAY,KAAK5B,GAAL,CAAS6B,mBAAT,GAA+B,CAA3C,CAFD,CAAP;AAGD;;;WAED,oBAAmBrB,KAAnB,EAA0C;AACxC,UAAI,KAAKR,GAAL,CAAS8B,aAAb,EAA4B;AAC1BtB,QAAAA,KAAK,GAAG,sCAAqBA,KAArB,CAAR;AACD;;AACD,UAAI,KAAKR,GAAL,CAAS+B,aAAT,KAA2B,QAA3B,IAAuC,KAAK/B,GAAL,CAAS+B,aAAT,KAA2B,SAAtE,EAAiF;AAC/EvB,QAAAA,KAAK,GAAG,sCAAqBA,KAArB,EAA4B,KAAKR,GAAL,CAAS+B,aAArC,EAAoD,0BAAa,KAAK/B,GAAlB,CAApD,CAAR;AACD;;AAED,aAAOQ,KAAP;AACD","sourcesContent":["import type { FormatOptions } from 'src/types';\nimport Params from './Params';\nimport Tokenizer from './Tokenizer';\nimport formatCommaPositions from './formatCommaPositions';\nimport formatAliasPositions from './formatAliasPositions';\nimport AsTokenFactory from './AsTokenFactory';\nimport Parser, { type Statement } from './Parser';\nimport StatementFormatter from './StatementFormatter';\nimport { type Token } from './token';\nimport { indentString } from './config';\n\n/** Main formatter class that produces a final output string from list of tokens */\nexport default class Formatter {\n  private cfg: FormatOptions;\n  private params: Params;\n\n  constructor(cfg: FormatOptions) {\n    this.cfg = cfg;\n    this.params = new Params(this.cfg.params);\n  }\n\n  /**\n   * SQL Tokenizer for this formatter, provided by subclasses.\n   */\n  protected tokenizer(): Tokenizer {\n    throw new Error('tokenizer() not implemented by subclass');\n  }\n\n  // Cache the tokenizer for each class (each SQL dialect)\n  // So we wouldn't need to recreate the tokenizer, which is kinda expensive,\n  // for each call to format() function.\n  private cachedTokenizer(): Tokenizer {\n    const cls: Function & { cachedTokenizer?: Tokenizer } = this.constructor;\n    if (!cls.cachedTokenizer) {\n      cls.cachedTokenizer = this.tokenizer();\n    }\n    return cls.cachedTokenizer;\n  }\n\n  /**\n   * Formats an SQL query.\n   * @param {string} query - The SQL query string to be formatted\n   * @return {string} The formatter query\n   */\n  public format(query: string): string {\n    const tokens = this.cachedTokenizer().tokenize(query);\n    const ast = new Parser(tokens).parse();\n    const formattedQuery = this.formatAst(ast, tokens);\n    const finalQuery = this.postFormat(formattedQuery);\n\n    return finalQuery.trimEnd();\n  }\n\n  private formatAst(statements: Statement[], tokens: Token[]): string {\n    const asTokenFactory = new AsTokenFactory(this.cfg.keywordCase, tokens);\n\n    return statements\n      .map(stat => new StatementFormatter(this.cfg, this.params, asTokenFactory).format(stat))\n      .join('\\n'.repeat(this.cfg.linesBetweenQueries + 1));\n  }\n\n  private postFormat(query: string): string {\n    if (this.cfg.tabulateAlias) {\n      query = formatAliasPositions(query);\n    }\n    if (this.cfg.commaPosition === 'before' || this.cfg.commaPosition === 'tabular') {\n      query = formatCommaPositions(query, this.cfg.commaPosition, indentString(this.cfg));\n    }\n\n    return query;\n  }\n}\n"],"file":"Formatter.js"}
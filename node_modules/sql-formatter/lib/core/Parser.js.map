{"version":3,"sources":["../../src/core/Parser.ts"],"names":["Parser","tokens","statements","stat","statement","push","look","value","next","type","TokenType","EOF","length","undefined","index","EOF_TOKEN"],"mappings":";;;;;;;AAAA;;;;;;;;;;AAQA;AACA;AACA;IACqBA,M;AAGnB,kBAAoBC,MAApB,EAAqC;AAAA;;AAAA,SAAjBA,MAAiB,GAAjBA,MAAiB;;AAAA,mCAFrB,CAEqB;AAAE;;;;WAEvC,iBAA4B;AAC1B,UAAMC,UAAuB,GAAG,EAAhC;AACA,UAAIC,IAAJ;;AACA,aAAQA,IAAI,GAAG,KAAKC,SAAL,EAAf,EAAkC;AAChCF,QAAAA,UAAU,CAACG,IAAX,CAAgBF,IAAhB;AACD;;AACD,aAAOD,UAAP;AACD;;;WAED,qBAA2C;AACzC,UAAMD,MAAe,GAAG,EAAxB;;AACA,aAAO,IAAP,EAAa;AACX,YAAI,KAAKK,IAAL,GAAYC,KAAZ,KAAsB,GAA1B,EAA+B;AAC7BN,UAAAA,MAAM,CAACI,IAAP,CAAY,KAAKG,IAAL,EAAZ;AACA,iBAAO;AAAEC,YAAAA,IAAI,EAAE,WAAR;AAAqBR,YAAAA,MAAM,EAANA;AAArB,WAAP;AACD,SAHD,MAGO,IAAI,KAAKK,IAAL,GAAYG,IAAZ,KAAqBC,iBAAUC,GAAnC,EAAwC;AAC7C,cAAIV,MAAM,CAACW,MAAP,GAAgB,CAApB,EAAuB;AACrB,mBAAO;AAAEH,cAAAA,IAAI,EAAE,WAAR;AAAqBR,cAAAA,MAAM,EAANA;AAArB,aAAP;AACD,WAFD,MAEO;AACL,mBAAOY,SAAP;AACD;AACF,SANM,MAMA;AACLZ,UAAAA,MAAM,CAACI,IAAP,CAAY,KAAKG,IAAL,EAAZ;AACD;AACF;AACF,K,CAED;;;;WACA,gBAAsB;AACpB,aAAO,KAAKP,MAAL,CAAY,KAAKa,KAAjB,KAA2BC,gBAAlC;AACD,K,CAED;;;;WACA,gBAAsB;AACpB,aAAO,KAAKd,MAAL,CAAY,KAAKa,KAAL,EAAZ,KAA6BC,gBAApC;AACD","sourcesContent":["import { EOF_TOKEN, type Token, TokenType } from './token';\n/* eslint-disable no-cond-assign */\n\nexport type Statement = {\n  type: 'statement';\n  tokens: Token[];\n};\n\n/**\n * A rudimentary parser that slices token stream into list of SQL statements.\n */\nexport default class Parser {\n  private index = 0;\n\n  constructor(private tokens: Token[]) {}\n\n  public parse(): Statement[] {\n    const statements: Statement[] = [];\n    let stat: Statement | undefined;\n    while ((stat = this.statement())) {\n      statements.push(stat);\n    }\n    return statements;\n  }\n\n  private statement(): Statement | undefined {\n    const tokens: Token[] = [];\n    while (true) {\n      if (this.look().value === ';') {\n        tokens.push(this.next());\n        return { type: 'statement', tokens };\n      } else if (this.look().type === TokenType.EOF) {\n        if (tokens.length > 0) {\n          return { type: 'statement', tokens };\n        } else {\n          return undefined;\n        }\n      } else {\n        tokens.push(this.next());\n      }\n    }\n  }\n\n  // Returns current token without advancing the pointer\n  private look(): Token {\n    return this.tokens[this.index] || EOF_TOKEN;\n  }\n\n  // Returns current token and advances the pointer to next token\n  private next(): Token {\n    return this.tokens[this.index++] || EOF_TOKEN;\n  }\n}\n"],"file":"Parser.js"}
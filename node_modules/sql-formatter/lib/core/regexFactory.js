"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createVariableRegex = exports.createReservedWordRegex = exports.createQuoteRegex = exports.createQuotePattern = exports.createParenRegex = exports.createParameterRegex = exports.createOperatorRegex = exports.createLineCommentRegex = exports.createIdentRegex = exports.createIdentPattern = void 0;

var _utils = require("../utils");

// This enables the following quote styles:
// 1. backtick quoted using `` to escape
// 2. square bracket quoted (SQL Server) using ]] to escape
// 3. double quoted using "" or \" to escape
// 4. single quoted using '' or \' to escape
// 5. PostgreSQL dollar-quoted
// 6. BigQuery '''triple-quoted'''
// 7. BigQuery """triple-quoted"""
// 8. Hive and Spark variables: ${name}
var quotePatterns = {
  '``': '(`[^`]*($|`))+',
  '[]': '(\\[[^\\]]*($|\\]))(\\][^\\]]*($|\\]))*',
  '""': '("[^"\\\\]*(?:\\\\.[^"\\\\]*)*("|$))+',
  "''": "('[^'\\\\]*(?:\\\\.[^'\\\\]*)*('|$))+",
  '$$': '(?<tag>\\$\\w*\\$)[\\s\\S]*?(?:\\k<tag>|$)',
  "'''..'''": "'''[^\\\\]*?(?:\\\\.[^\\\\]*?)*?('''|$)",
  '""".."""': '"""[^\\\\]*?(?:\\\\.[^\\\\]*?)*?("""|$)',
  '{}': '(\\{[^\\}]*($|\\}))'
};

/**
 * Builds a RegExp containing all operators for a SQL dialect
 * @param {string} monadOperators - concatenated string of all 1-length operators
 * @param {string[]} polyadOperators - list of strings of all >1-length operators
 */
var createOperatorRegex = function createOperatorRegex(monadOperators, polyadOperators) {
  return patternToRegex("".concat((0, _utils.sortByLengthDesc)(polyadOperators).map(_utils.escapeRegExp).join('|'), "|") + "[".concat(monadOperators.split('').map(_utils.escapeRegExp).join(''), "]"));
};
/**
 * Builds a RegExp for valid line comments in a SQL dialect
 * @param {string[]} lineCommentTypes - list of character strings that denote line comments
 */


exports.createOperatorRegex = createOperatorRegex;

var createLineCommentRegex = function createLineCommentRegex(lineCommentTypes) {
  return new RegExp("((?:".concat(lineCommentTypes.map(function (c) {
    return (0, _utils.escapeRegExp)(c);
  }).join('|'), ").*?)(?:\r\n|\r|\n|$)"), 'uy');
};
/**
 * Builds a RegExp for all Reserved Keywords in a SQL dialect
 */


exports.createLineCommentRegex = createLineCommentRegex;

var createReservedWordRegex = function createReservedWordRegex(reservedKeywords) {
  var identChars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (reservedKeywords.length === 0) {
    return new RegExp("\\b$", "y");
  }

  var avoidIdentChars = rejectIdentCharsPattern(identChars);
  var reservedKeywordsPattern = (0, _utils.sortByLengthDesc)(reservedKeywords).join('|').replace(/ /g, '\\s+');
  return new RegExp("(".concat(reservedKeywordsPattern, ")").concat(avoidIdentChars, "\\b"), 'iuy');
}; // Negative lookahead to avoid matching a keyword that's actually part of identifier,
// which can happen when identifier allows word-boundary characters inside it.
//
// For example "SELECT$ME" should be tokenized as:
// - ["SELECT$ME"] when $ is allowed inside identifiers
// - ["SELECT", "$", "ME"] when $ can't be part of identifiers.


exports.createReservedWordRegex = createReservedWordRegex;

var rejectIdentCharsPattern = function rejectIdentCharsPattern(_ref) {
  var rest = _ref.rest,
      dashes = _ref.dashes;
  return rest || dashes ? "(?![".concat(rest || '').concat(dashes ? '-' : '', "])") : '';
};
/**
 * Builds a RegExp for valid identifiers in a SQL dialect
 */


var createIdentRegex = function createIdentRegex() {
  var specialChars = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return patternToRegex(createIdentPattern(specialChars));
};
/**
 * Builds a RegExp string for valid identifiers in a SQL dialect
 */


exports.createIdentRegex = createIdentRegex;

var createIdentPattern = function createIdentPattern() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      first = _ref2.first,
      rest = _ref2.rest,
      dashes = _ref2.dashes;

  // Unicode letters, diacritical marks and underscore
  var letter = '\\p{Alphabetic}\\p{Mark}_'; // Numbers 0..9, plus various unicode numbers

  var number = '\\p{Decimal_Number}';
  var firstChars = (0, _utils.escapeRegExp)(first !== null && first !== void 0 ? first : '');
  var restChars = (0, _utils.escapeRegExp)(rest !== null && rest !== void 0 ? rest : '');
  var pattern = "[".concat(letter).concat(firstChars, "][").concat(letter).concat(number).concat(restChars, "]*");
  return dashes ? withDashes(pattern) : pattern;
};

exports.createIdentPattern = createIdentPattern;

var withDashes = function withDashes(pattern) {
  return pattern + '(?:-' + pattern + ')*';
}; // Converts "ab" to "[Aa][Bb]"


var toCaseInsensitivePattern = function toCaseInsensitivePattern(prefix) {
  return prefix.split('').map(function (_char) {
    return '[' + _char.toUpperCase() + _char.toLowerCase() + ']';
  }).join('');
}; // Converts ["a", "b"] to "(?:[Aa]|[Bb]|)" or "(?:[Aa]|[Bb])" when required = true


var prefixesPattern = function prefixesPattern(_ref3) {
  var prefixes = _ref3.prefixes,
      required = _ref3.required;
  return '(?:' + prefixes.map(toCaseInsensitivePattern).join('|') + (required ? '' : '|') + ')';
};

var createSingleQuotePattern = function createSingleQuotePattern(type) {
  if (typeof type === 'string') {
    return quotePatterns[type];
  } else {
    return prefixesPattern(type) + quotePatterns[type.quote];
  }
};
/** Builds a quote-delimited pattern for matching all given quote types */


var createQuotePattern = function createQuotePattern(quoteTypes) {
  return quoteTypes.map(createSingleQuotePattern).join('|');
};

exports.createQuotePattern = createQuotePattern;

var createSingleVariablePattern = function createSingleVariablePattern(type) {
  if ('regex' in type) {
    return type.regex;
  } else {
    return createSingleQuotePattern(type);
  }
};
/** Builds a RegExp for matching variables */


var createVariableRegex = function createVariableRegex(varTypes) {
  return patternToRegex(varTypes.map(createSingleVariablePattern).join('|'));
};
/** Builds a RegExp for matching quote-delimited patterns */


exports.createVariableRegex = createVariableRegex;

var createQuoteRegex = function createQuoteRegex(quoteTypes) {
  return patternToRegex(createQuotePattern(quoteTypes));
};
/** Escapes paren characters for RegExp patterns */


exports.createQuoteRegex = createQuoteRegex;

var escapeParen = function escapeParen(paren) {
  if (paren.length === 1) {
    // A single punctuation character
    return (0, _utils.escapeRegExp)(paren);
  } else {
    // longer word
    return '\\b' + paren + '\\b';
  }
};
/**
 * Builds a RegExp for matching parenthesis patterns, escaping them with `escapeParen`
 * @param {string[]} parens - list of strings that denote parenthesis patterns
 */


var createParenRegex = function createParenRegex(parens) {
  return patternToRegex(parens.map(escapeParen).join('|'));
};
/**
 * Builds a RegExp for parameter placeholder patterns
 * @param {string[]} types - list of strings that denote placeholder types
 * @param {string} pattern - string that denotes placeholder pattern
 */


exports.createParenRegex = createParenRegex;

var createParameterRegex = function createParameterRegex(types, pattern) {
  if ((0, _utils.isEmpty)(types)) {
    return undefined;
  }

  var typesRegex = types.map(_utils.escapeRegExp).join('|');
  return patternToRegex("(?:".concat(typesRegex, ")(?:").concat(pattern, ")"));
};

exports.createParameterRegex = createParameterRegex;

var patternToRegex = function patternToRegex(pattern) {
  return new RegExp('(' + pattern + ')', 'uy');
};
//# sourceMappingURL=regexFactory.js.map
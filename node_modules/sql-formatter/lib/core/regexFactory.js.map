{"version":3,"sources":["../../src/core/regexFactory.ts"],"names":["quotePatterns","createOperatorRegex","monadOperators","polyadOperators","patternToRegex","map","escapeRegExp","join","split","createLineCommentRegex","lineCommentTypes","RegExp","c","createReservedWordRegex","reservedKeywords","identChars","length","avoidIdentChars","rejectIdentCharsPattern","reservedKeywordsPattern","replace","rest","dashes","createIdentRegex","specialChars","createIdentPattern","first","letter","number","firstChars","restChars","pattern","withDashes","toCaseInsensitivePattern","prefix","char","toUpperCase","toLowerCase","prefixesPattern","prefixes","required","createSingleQuotePattern","type","quote","createQuotePattern","quoteTypes","createSingleVariablePattern","regex","createVariableRegex","varTypes","createQuoteRegex","escapeParen","paren","createParenRegex","parens","createParameterRegex","types","undefined","typesRegex"],"mappings":"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","sourcesContent":["import { escapeRegExp, isEmpty, sortByLengthDesc } from 'src/utils';\n\n// This enables the following quote styles:\n// 1. backtick quoted using `` to escape\n// 2. square bracket quoted (SQL Server) using ]] to escape\n// 3. double quoted using \"\" or \\\" to escape\n// 4. single quoted using '' or \\' to escape\n// 5. PostgreSQL dollar-quoted\n// 6. BigQuery '''triple-quoted'''\n// 7. BigQuery \"\"\"triple-quoted\"\"\"\n// 8. Hive and Spark variables: ${name}\nconst quotePatterns = {\n  '``': '(`[^`]*($|`))+',\n  '[]': '(\\\\[[^\\\\]]*($|\\\\]))(\\\\][^\\\\]]*($|\\\\]))*',\n  '\"\"': '(\"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*(\"|$))+',\n  \"''\": \"('[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*('|$))+\",\n  '$$': '(?<tag>\\\\$\\\\w*\\\\$)[\\\\s\\\\S]*?(?:\\\\k<tag>|$)',\n  \"'''..'''\": \"'''[^\\\\\\\\]*?(?:\\\\\\\\.[^\\\\\\\\]*?)*?('''|$)\",\n  '\"\"\"..\"\"\"': '\"\"\"[^\\\\\\\\]*?(?:\\\\\\\\.[^\\\\\\\\]*?)*?(\"\"\"|$)',\n  '{}': '(\\\\{[^\\\\}]*($|\\\\}))',\n};\nexport type PlainQuoteType = keyof typeof quotePatterns;\n\nexport type PrefixedQuoteType = {\n  quote: PlainQuoteType;\n  prefixes: string[];\n  required?: boolean; // True when prefix is required\n};\n\nexport type QuoteType = PlainQuoteType | PrefixedQuoteType;\n\nexport interface VariableRegex {\n  regex: string;\n}\n\nexport type VariableType = VariableRegex | PrefixedQuoteType;\n\nexport interface IdentChars {\n  // Additional characters that can be used as first character of an identifier.\n  // That is: in addition to letters and underscore.\n  first?: string;\n  // Additional characters that can appear after the first character of identifier.\n  // That is: in addition to letters, numbers and underscore.\n  rest?: string;\n  // True to allow single dashes (-) inside identifiers, but not at the beginning or end\n  dashes?: boolean;\n}\n\n/**\n * Builds a RegExp containing all operators for a SQL dialect\n * @param {string} monadOperators - concatenated string of all 1-length operators\n * @param {string[]} polyadOperators - list of strings of all >1-length operators\n */\nexport const createOperatorRegex = (monadOperators: string, polyadOperators: string[]): RegExp =>\n  patternToRegex(\n    `${sortByLengthDesc(polyadOperators).map(escapeRegExp).join('|')}|` +\n      `[${monadOperators.split('').map(escapeRegExp).join('')}]`\n  );\n\n/**\n * Builds a RegExp for valid line comments in a SQL dialect\n * @param {string[]} lineCommentTypes - list of character strings that denote line comments\n */\nexport const createLineCommentRegex = (lineCommentTypes: string[]): RegExp =>\n  new RegExp(\n    `^((?:${lineCommentTypes.map(c => escapeRegExp(c)).join('|')}).*?)(?:\\r\\n|\\r|\\n|$)`,\n    'u'\n  );\n\n/**\n * Builds a RegExp for all Reserved Keywords in a SQL dialect\n */\nexport const createReservedWordRegex = (\n  reservedKeywords: string[],\n  identChars: IdentChars = {}\n): RegExp => {\n  if (reservedKeywords.length === 0) {\n    return /^\\b$/u;\n  }\n\n  const avoidIdentChars = rejectIdentCharsPattern(identChars);\n\n  const reservedKeywordsPattern = sortByLengthDesc(reservedKeywords)\n    .join('|')\n    .replace(/ /gu, '\\\\s+');\n\n  return new RegExp(`^(${reservedKeywordsPattern})${avoidIdentChars}\\\\b`, 'iu');\n};\n\n// Negative lookahead to avoid matching a keyword that's actually part of identifier,\n// which can happen when identifier allows word-boundary characters inside it.\n//\n// For example \"SELECT$ME\" should be tokenized as:\n// - [\"SELECT$ME\"] when $ is allowed inside identifiers\n// - [\"SELECT\", \"$\", \"ME\"] when $ can't be part of identifiers.\nconst rejectIdentCharsPattern = ({ rest, dashes }: IdentChars): string =>\n  rest || dashes ? `(?![${rest || ''}${dashes ? '-' : ''}])` : '';\n\n/**\n * Builds a RegExp for valid identifiers in a SQL dialect\n */\nexport const createIdentRegex = (specialChars: IdentChars = {}): RegExp =>\n  patternToRegex(createIdentPattern(specialChars));\n\n/**\n * Builds a RegExp string for valid identifiers in a SQL dialect\n */\nexport const createIdentPattern = ({ first, rest, dashes }: IdentChars = {}): string => {\n  // Unicode letters, diacritical marks and underscore\n  const letter = '\\\\p{Alphabetic}\\\\p{Mark}_';\n  // Numbers 0..9, plus various unicode numbers\n  const number = '\\\\p{Decimal_Number}';\n\n  const firstChars = escapeRegExp(first ?? '');\n  const restChars = escapeRegExp(rest ?? '');\n\n  const pattern = `[${letter}${firstChars}][${letter}${number}${restChars}]*`;\n\n  return dashes ? withDashes(pattern) : pattern;\n};\n\nconst withDashes = (pattern: string): string => pattern + '(?:-' + pattern + ')*';\n\n// Converts \"ab\" to \"[Aa][Bb]\"\nconst toCaseInsensitivePattern = (prefix: string): string =>\n  prefix\n    .split('')\n    .map(char => '[' + char.toUpperCase() + char.toLowerCase() + ']')\n    .join('');\n\n// Converts [\"a\", \"b\"] to \"(?:[Aa]|[Bb]|)\" or \"(?:[Aa]|[Bb])\" when required = true\nconst prefixesPattern = ({ prefixes, required }: PrefixedQuoteType): string =>\n  '(?:' + prefixes.map(toCaseInsensitivePattern).join('|') + (required ? '' : '|') + ')';\n\nconst createSingleQuotePattern = (type: QuoteType): string => {\n  if (typeof type === 'string') {\n    return quotePatterns[type];\n  } else {\n    return prefixesPattern(type) + quotePatterns[type.quote];\n  }\n};\n\n/** Builds a quote-delimited pattern for matching all given quote types */\nexport const createQuotePattern = (quoteTypes: QuoteType[]): string =>\n  quoteTypes.map(createSingleQuotePattern).join('|');\n\nconst createSingleVariablePattern = (type: VariableType): string => {\n  if ('regex' in type) {\n    return type.regex;\n  } else {\n    return createSingleQuotePattern(type);\n  }\n};\n\n/** Builds a RegExp for matching variables */\nexport const createVariableRegex = (varTypes: VariableType[]): RegExp =>\n  patternToRegex(varTypes.map(createSingleVariablePattern).join('|'));\n\n/** Builds a RegExp for matching quote-delimited patterns */\nexport const createQuoteRegex = (quoteTypes: QuoteType[]): RegExp =>\n  patternToRegex(createQuotePattern(quoteTypes));\n\n/** Escapes paren characters for RegExp patterns */\nconst escapeParen = (paren: string): string => {\n  if (paren.length === 1) {\n    // A single punctuation character\n    return escapeRegExp(paren);\n  } else {\n    // longer word\n    return '\\\\b' + paren + '\\\\b';\n  }\n};\n\n/**\n * Builds a RegExp for matching parenthesis patterns, escaping them with `escapeParen`\n * @param {string[]} parens - list of strings that denote parenthesis patterns\n */\nexport const createParenRegex = (parens: string[]): RegExp =>\n  patternToRegex(parens.map(escapeParen).join('|'));\n\n/**\n * Builds a RegExp for parameter placeholder patterns\n * @param {string[]} types - list of strings that denote placeholder types\n * @param {string} pattern - string that denotes placeholder pattern\n */\nexport const createParameterRegex = (types: string[], pattern: string): RegExp | undefined => {\n  if (isEmpty(types)) {\n    return undefined;\n  }\n  const typesRegex = types.map(escapeRegExp).join('|');\n\n  return patternToRegex(`(?:${typesRegex})(?:${pattern})`);\n};\n\nconst patternToRegex = (pattern: string): RegExp => new RegExp('^(' + pattern + ')', 'u');\n"],"file":"regexFactory.js"}
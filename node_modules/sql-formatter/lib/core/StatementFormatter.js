"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _utils = require("../utils");

var _Indentation = _interopRequireDefault(require("./Indentation"));

var _InlineBlock = _interopRequireDefault(require("./InlineBlock"));

var _token = require("./token");

var _tabularStyle = _interopRequireDefault(require("./tabularStyle"));

var _AliasAs = _interopRequireDefault(require("./AliasAs"));

var _config = require("./config");

var _WhitespaceBuilder = _interopRequireWildcard(require("./WhitespaceBuilder"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Formats single SQL statement */
var StatementFormatter = /*#__PURE__*/function () {
  function StatementFormatter(cfg, params, asTokenFactory) {
    _classCallCheck(this, StatementFormatter);

    _defineProperty(this, "cfg", void 0);

    _defineProperty(this, "indentation", void 0);

    _defineProperty(this, "inlineBlock", void 0);

    _defineProperty(this, "aliasAs", void 0);

    _defineProperty(this, "params", void 0);

    _defineProperty(this, "asTokenFactory", void 0);

    _defineProperty(this, "query", void 0);

    _defineProperty(this, "currentNewline", true);

    _defineProperty(this, "previousReservedToken", _token.EOF_TOKEN);

    _defineProperty(this, "previousCommandToken", _token.EOF_TOKEN);

    _defineProperty(this, "tokens", []);

    _defineProperty(this, "index", -1);

    this.cfg = cfg;
    this.indentation = new _Indentation["default"]((0, _config.indentString)(cfg));
    this.inlineBlock = new _InlineBlock["default"](this.cfg.expressionWidth);
    this.aliasAs = new _AliasAs["default"](this.cfg.aliasAs, this);
    this.params = params;
    this.asTokenFactory = asTokenFactory;
    this.query = new _WhitespaceBuilder["default"](this.indentation);
  }

  _createClass(StatementFormatter, [{
    key: "format",
    value: function format(statement) {
      this.tokens = statement.tokens;

      for (this.index = 0; this.index < this.tokens.length; this.index++) {
        var token = this.tokens[this.index]; // if token is a Reserved Keyword, Command, Binary Command, Dependent Clause, Logical Operator, CASE, END

        if ((0, _token.isReserved)(token)) {
          this.previousReservedToken = token;

          if (token.type === _token.TokenType.RESERVED_COMMAND) {
            this.previousCommandToken = token;
          }
        }

        this.formatToken(token);
      }

      return this.query.toString();
    }
  }, {
    key: "formatToken",
    value: function formatToken(token) {
      switch (token.type) {
        case _token.TokenType.LINE_COMMENT:
          return this.formatLineComment(token);

        case _token.TokenType.BLOCK_COMMENT:
          return this.formatBlockComment(token);

        case _token.TokenType.RESERVED_COMMAND:
          this.currentNewline = this.checkNewline(token);
          return this.formatCommand(token);

        case _token.TokenType.RESERVED_BINARY_COMMAND:
          return this.formatBinaryCommand(token);

        case _token.TokenType.RESERVED_DEPENDENT_CLAUSE:
          return this.formatDependentClause(token);

        case _token.TokenType.RESERVED_JOIN_CONDITION:
          return this.formatJoinCondition(token);

        case _token.TokenType.RESERVED_LOGICAL_OPERATOR:
          return this.formatLogicalOperator(token);

        case _token.TokenType.RESERVED_KEYWORD:
          return this.formatKeyword(token);

        case _token.TokenType.BLOCK_START:
          return this.formatBlockStart(token);

        case _token.TokenType.BLOCK_END:
          return this.formatBlockEnd(token);

        case _token.TokenType.RESERVED_CASE_START:
          return this.formatCaseStart(token);

        case _token.TokenType.RESERVED_CASE_END:
          return this.formatCaseEnd(token);

        case _token.TokenType.PARAMETER:
          return this.formatParameter(token);

        case _token.TokenType.OPERATOR:
          return this.formatOperator(token);

        case _token.TokenType.IDENT:
        case _token.TokenType.STRING:
        case _token.TokenType.NUMBER:
        case _token.TokenType.VARIABLE:
          return this.formatWord(token);

        default:
          throw new Error("Unexpected token type: ".concat(token.type));
      }
    }
    /**
     * Formats word tokens + any potential AS tokens for aliases
     */

  }, {
    key: "formatWord",
    value: function formatWord(token) {
      if (this.aliasAs.shouldAddBefore(token)) {
        this.query.add(this.show(this.asTokenFactory.token()), _WhitespaceBuilder.WS.SPACE);
      }

      this.query.add(this.show(token), _WhitespaceBuilder.WS.SPACE);

      if (this.aliasAs.shouldAddAfter()) {
        this.query.add(this.show(this.asTokenFactory.token()), _WhitespaceBuilder.WS.SPACE);
      }
    }
    /**
     * Checks if a newline should currently be inserted
     */

  }, {
    key: "checkNewline",
    value: function checkNewline(token) {
      var nextTokens = this.tokensUntilNextCommandOrQueryEnd(); // auto break if SELECT includes CASE statements

      if (this.isWithinSelect() && nextTokens.some(_token.isToken.CASE)) {
        return true;
      }

      switch (this.cfg.multilineLists) {
        case 'always':
          return true;

        case 'avoid':
          return false;

        case 'expressionWidth':
          return this.inlineWidth(token, nextTokens) > this.cfg.expressionWidth;

        default:
          // multilineLists mode is a number
          return this.countClauses(nextTokens) > this.cfg.multilineLists || this.inlineWidth(token, nextTokens) > this.cfg.expressionWidth;
      }
    }
  }, {
    key: "inlineWidth",
    value: function inlineWidth(token, tokens) {
      var tokensString = tokens.map(function (_ref) {
        var value = _ref.value;
        return value === ',' ? value + ' ' : value;
      }).join('');
      return "".concat(token.whitespaceBefore).concat(token.value, " ").concat(tokensString).length;
    }
    /**
     * Counts comma-separated clauses (doesn't count commas inside blocks)
     * Note: There's always at least one clause.
     */

  }, {
    key: "countClauses",
    value: function countClauses(tokens) {
      var count = 1;
      var openBlocks = 0;

      var _iterator = _createForOfIteratorHelper(tokens),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _step.value,
              type = _step$value.type,
              value = _step$value.value;

          if (value === ',' && openBlocks === 0) {
            count++;
          }

          if (type === _token.TokenType.BLOCK_START) {
            openBlocks++;
          }

          if (type === _token.TokenType.BLOCK_END) {
            openBlocks--;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return count;
    }
    /** get all tokens between current token and next Reserved Command or query end */

  }, {
    key: "tokensUntilNextCommandOrQueryEnd",
    value: function tokensUntilNextCommandOrQueryEnd() {
      var tail = this.tokens.slice(this.index + 1);
      return tail.slice(0, tail.length ? tail.findIndex(function (token) {
        return (0, _token.isCommand)(token) || token.value === ';';
      }) : undefined);
    }
    /** Formats a line comment onto query */

  }, {
    key: "formatLineComment",
    value: function formatLineComment(token) {
      this.query.add(this.show(token), _WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT);
    }
    /** Formats a block comment onto query */

  }, {
    key: "formatBlockComment",
    value: function formatBlockComment(token) {
      this.query.add(_WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT, this.indentComment(token.value), _WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT);
    }
    /** Aligns comment to current indentation level */

  }, {
    key: "indentComment",
    value: function indentComment(comment) {
      return comment.replace(/\n[\t ]*/g, '\n' + this.indentation.getIndent() + ' ');
    }
    /**
     * Formats a Reserved Command onto query, increasing indentation level where necessary
     */

  }, {
    key: "formatCommand",
    value: function formatCommand(token) {
      this.indentation.decreaseTopLevel();
      this.query.add(_WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT); // indent tabular formats, except when preceding a (

      if ((0, _config.isTabularStyle)(this.cfg)) {
        if (this.tokenLookAhead().value !== '(') {
          this.indentation.increaseTopLevel();
        }
      } else {
        this.indentation.increaseTopLevel();
      }

      if (this.currentNewline && !(0, _config.isTabularStyle)(this.cfg)) {
        this.query.add(this.show(token), _WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT);
      } else {
        this.query.add(this.show(token), _WhitespaceBuilder.WS.SPACE);
      }
    }
    /**
     * Formats a Reserved Binary Command onto query, joining neighbouring tokens
     */

  }, {
    key: "formatBinaryCommand",
    value: function formatBinaryCommand(token) {
      var isJoin = /JOIN/i.test(token.value); // check if token contains JOIN

      if (!isJoin || (0, _config.isTabularStyle)(this.cfg)) {
        // decrease for boolean set operators or in tabular mode
        this.indentation.decreaseTopLevel();
      }

      if (isJoin) {
        this.query.add(_WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT, this.show(token), _WhitespaceBuilder.WS.SPACE);
      } else {
        this.query.add(_WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT, this.show(token), _WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT);
      }
    }
    /**
     * Formats a Reserved Keyword onto query, skipping AS if disabled
     */

  }, {
    key: "formatKeyword",
    value: function formatKeyword(token) {
      if (_token.isToken.AS(token) && this.aliasAs.shouldRemove()) {
        return;
      }

      this.query.add(this.show(token), _WhitespaceBuilder.WS.SPACE);
    }
    /**
     * Formats a Reserved Dependent Clause token onto query, supporting the keyword that precedes it
     */

  }, {
    key: "formatDependentClause",
    value: function formatDependentClause(token) {
      this.query.add(_WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT, this.show(token), _WhitespaceBuilder.WS.SPACE);
    } // Formats ON and USING keywords

  }, {
    key: "formatJoinCondition",
    value: function formatJoinCondition(token) {
      this.query.add(this.show(token), _WhitespaceBuilder.WS.SPACE);
    }
    /**
     * Formats an Operator onto query, following rules for specific characters
     */

  }, {
    key: "formatOperator",
    value: function formatOperator(token) {
      // special operator
      if (token.value === ',') {
        this.formatComma(token);
        return;
      } else if (token.value === ';') {
        this.formatQuerySeparator(token);
        return;
      } else if (['$', '['].includes(token.value)) {
        this.query.add(this.show(token));
        return;
      } else if ([':', ']'].includes(token.value)) {
        this.query.add(_WhitespaceBuilder.WS.NO_SPACE, this.show(token), _WhitespaceBuilder.WS.SPACE);
        return;
      } else if (['.', '{', '}', '`'].includes(token.value)) {
        this.query.add(_WhitespaceBuilder.WS.NO_SPACE, this.show(token));
        return;
      } // other operators
      // in dense operators mode do not trim whitespace if SELECT *


      if (this.cfg.denseOperators && this.tokenLookBehind().type !== _token.TokenType.RESERVED_COMMAND) {
        this.query.add(_WhitespaceBuilder.WS.NO_SPACE, this.show(token));
      } else {
        this.query.add(this.show(token), _WhitespaceBuilder.WS.SPACE);
      }
    }
    /**
     * Formats a Logical Operator onto query, joining boolean conditions
     */

  }, {
    key: "formatLogicalOperator",
    value: function formatLogicalOperator(token) {
      // ignore AND when BETWEEN x [AND] y
      if (_token.isToken.AND(token) && _token.isToken.BETWEEN(this.tokenLookBehind(2))) {
        this.query.add(this.show(token), _WhitespaceBuilder.WS.SPACE);
        return;
      }

      if ((0, _config.isTabularStyle)(this.cfg)) {
        this.indentation.decreaseTopLevel();
      }

      if (this.cfg.logicalOperatorNewline === 'before') {
        if (this.currentNewline) {
          this.query.add(_WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT, this.show(token), _WhitespaceBuilder.WS.SPACE);
        } else {
          this.query.add(this.show(token), _WhitespaceBuilder.WS.SPACE);
        }
      } else {
        // eslint-disable-next-line no-lonely-if
        if (this.currentNewline) {
          this.query.add(this.show(token), _WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT);
        } else {
          this.query.add(this.show(token));
        }
      }
    }
  }, {
    key: "formatBlockStart",
    value: function formatBlockStart(token) {
      var _token$whitespaceBefo;

      // Take out the preceding space unless there was whitespace there in the original query
      // or another opening parens or line comment
      var preserveWhitespaceFor = [_token.TokenType.BLOCK_START, _token.TokenType.LINE_COMMENT, _token.TokenType.OPERATOR];

      if (((_token$whitespaceBefo = token.whitespaceBefore) === null || _token$whitespaceBefo === void 0 ? void 0 : _token$whitespaceBefo.length) === 0 && !preserveWhitespaceFor.includes(this.tokenLookBehind().type)) {
        this.query.add(_WhitespaceBuilder.WS.NO_SPACE, this.show(token));
      } else if (!this.cfg.newlineBeforeOpenParen) {
        this.query.add(_WhitespaceBuilder.WS.NO_NEWLINE, _WhitespaceBuilder.WS.SPACE, this.show(token));
      } else {
        this.query.add(this.show(token));
      }

      this.inlineBlock.beginIfPossible(this.tokens, this.index);

      if (!this.inlineBlock.isActive()) {
        this.indentation.increaseBlockLevel();
        this.query.add(_WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT);
      }
    }
  }, {
    key: "formatBlockEnd",
    value: function formatBlockEnd(token) {
      if (this.inlineBlock.isActive()) {
        this.inlineBlock.end();
        this.query.add(_WhitespaceBuilder.WS.NO_SPACE, this.show(token), _WhitespaceBuilder.WS.SPACE);
      } else {
        this.formatMultilineBlockEnd(token);
      }
    }
  }, {
    key: "formatCaseStart",
    value: function formatCaseStart(token) {
      this.indentation.increaseBlockLevel();

      if (this.cfg.multilineLists === 'always') {
        this.query.add(this.show(token), _WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT);
      } else {
        this.query.add(this.show(token), _WhitespaceBuilder.WS.SPACE);
      }
    }
  }, {
    key: "formatCaseEnd",
    value: function formatCaseEnd(token) {
      this.formatMultilineBlockEnd(token);
    }
  }, {
    key: "formatMultilineBlockEnd",
    value: function formatMultilineBlockEnd(token) {
      this.indentation.decreaseBlockLevel();

      if ((0, _config.isTabularStyle)(this.cfg)) {
        // +1 extra indentation step for the closing paren
        this.query.add(_WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT, _WhitespaceBuilder.WS.SINGLE_INDENT, this.show(token), _WhitespaceBuilder.WS.SPACE);
      } else if (this.cfg.newlineBeforeCloseParen) {
        this.query.add(_WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT, this.show(token), _WhitespaceBuilder.WS.SPACE);
      } else {
        this.query.add(_WhitespaceBuilder.WS.NO_NEWLINE, _WhitespaceBuilder.WS.SPACE, this.show(token), _WhitespaceBuilder.WS.SPACE);
      }
    }
    /**
     * Formats a parameter placeholder item onto query, to be replaced with the value of the placeholder
     */

  }, {
    key: "formatParameter",
    value: function formatParameter(token) {
      this.query.add(this.params.get(token), _WhitespaceBuilder.WS.SPACE);
    }
    /**
     * Formats a comma Operator onto query, ending line unless in an Inline Block
     */

  }, {
    key: "formatComma",
    value: function formatComma(token) {
      if (!this.inlineBlock.isActive() && !_token.isToken.LIMIT(this.getPreviousReservedToken()) && this.currentNewline) {
        this.query.add(_WhitespaceBuilder.WS.NO_SPACE, this.show(token), _WhitespaceBuilder.WS.NEWLINE, _WhitespaceBuilder.WS.INDENT);
      } else {
        this.query.add(_WhitespaceBuilder.WS.NO_SPACE, this.show(token), _WhitespaceBuilder.WS.SPACE);
      }
    }
  }, {
    key: "formatQuerySeparator",
    value: function formatQuerySeparator(token) {
      if (this.cfg.newlineBeforeSemicolon) {
        this.query.add(_WhitespaceBuilder.WS.NEWLINE, this.show(token));
      } else {
        this.query.add(_WhitespaceBuilder.WS.NO_SPACE, this.show(token));
      }
    }
  }, {
    key: "show",
    value: function show(token) {
      if (this.isTabularToken(token)) {
        return (0, _tabularStyle["default"])(this.showToken(token), this.cfg.indentStyle);
      } else {
        return this.showToken(token);
      }
    } // These token types can be formatted in tabular style

  }, {
    key: "isTabularToken",
    value: function isTabularToken(token) {
      return token.type === _token.TokenType.RESERVED_LOGICAL_OPERATOR || token.type === _token.TokenType.RESERVED_DEPENDENT_CLAUSE || token.type === _token.TokenType.RESERVED_COMMAND || token.type === _token.TokenType.RESERVED_BINARY_COMMAND;
    } // don't call this directly, always use show() instead.

  }, {
    key: "showToken",
    value: function showToken(token) {
      if ((0, _token.isReserved)(token)) {
        switch (this.cfg.keywordCase) {
          case 'preserve':
            return (0, _utils.equalizeWhitespace)(token.text);

          case 'upper':
            return token.value;

          case 'lower':
            return token.value.toLowerCase();
        }
      } else {
        return token.value;
      }
    }
    /** Returns the latest encountered reserved keyword token */

  }, {
    key: "getPreviousReservedToken",
    value: function getPreviousReservedToken() {
      return this.previousReservedToken;
    }
    /** True when currently within SELECT command */

  }, {
    key: "isWithinSelect",
    value: function isWithinSelect() {
      return _token.isToken.SELECT(this.previousCommandToken);
    }
    /** Fetches nth previous token from the token stream */

  }, {
    key: "tokenLookBehind",
    value: function tokenLookBehind() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return this.tokens[this.index - n] || _token.EOF_TOKEN;
    }
    /** Fetches nth next token from the token stream */

  }, {
    key: "tokenLookAhead",
    value: function tokenLookAhead() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return this.tokens[this.index + n] || _token.EOF_TOKEN;
    }
  }]);

  return StatementFormatter;
}();

exports["default"] = StatementFormatter;
module.exports = exports.default;
//# sourceMappingURL=StatementFormatter.js.map
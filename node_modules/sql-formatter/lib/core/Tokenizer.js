"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.WHITESPACE_REGEX = void 0;

var _utils = require("../utils");

var regexFactory = _interopRequireWildcard(require("./regexFactory"));

var _token = require("./token");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var WHITESPACE_REGEX = /^([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+)/;
exports.WHITESPACE_REGEX = WHITESPACE_REGEX;
var NULL_REGEX = /(?!)/; // zero-width negative lookahead, matches nothing

var toCanonicalKeyword = function toCanonicalKeyword(text) {
  return (0, _utils.equalizeWhitespace)(text.toUpperCase());
};
/** Struct that defines how a SQL language can be broken into tokens */


/** Converts SQL language string into a token stream */
var Tokenizer = /*#__PURE__*/function () {
  function Tokenizer(cfg) {
    var _cfg$reservedDependen,
        _cfg$reservedLogicalO,
        _cfg$reservedJoinCond,
        _cfg$operators,
        _cfg$blockStart,
        _cfg$blockEnd,
        _cfg$lineCommentTypes,
        _this$REGEX_MAP,
        _cfg$namedParamTypes,
        _cfg$quotedParamTypes,
        _this = this,
        _cfg$numberedParamTyp;

    _classCallCheck(this, Tokenizer);

    _defineProperty(this, "REGEX_MAP", void 0);

    _defineProperty(this, "quotedIdentRegex", void 0);

    _defineProperty(this, "paramPatterns", void 0);

    _defineProperty(this, "preprocess", function (tokens) {
      return tokens;
    });

    if (cfg.preprocess) {
      this.preprocess = cfg.preprocess;
    }

    this.quotedIdentRegex = regexFactory.createQuoteRegex(cfg.identTypes);
    this.REGEX_MAP = (_this$REGEX_MAP = {}, _defineProperty(_this$REGEX_MAP, _token.TokenType.IDENT, regexFactory.createIdentRegex(cfg.identChars)), _defineProperty(_this$REGEX_MAP, _token.TokenType.STRING, regexFactory.createQuoteRegex(cfg.stringTypes)), _defineProperty(_this$REGEX_MAP, _token.TokenType.VARIABLE, cfg.variableTypes ? regexFactory.createVariableRegex(cfg.variableTypes) : NULL_REGEX), _defineProperty(_this$REGEX_MAP, _token.TokenType.RESERVED_KEYWORD, regexFactory.createReservedWordRegex(cfg.reservedKeywords, cfg.identChars)), _defineProperty(_this$REGEX_MAP, _token.TokenType.RESERVED_DEPENDENT_CLAUSE, regexFactory.createReservedWordRegex((_cfg$reservedDependen = cfg.reservedDependentClauses) !== null && _cfg$reservedDependen !== void 0 ? _cfg$reservedDependen : [], cfg.identChars)), _defineProperty(_this$REGEX_MAP, _token.TokenType.RESERVED_LOGICAL_OPERATOR, regexFactory.createReservedWordRegex((_cfg$reservedLogicalO = cfg.reservedLogicalOperators) !== null && _cfg$reservedLogicalO !== void 0 ? _cfg$reservedLogicalO : ['AND', 'OR'], cfg.identChars)), _defineProperty(_this$REGEX_MAP, _token.TokenType.RESERVED_COMMAND, regexFactory.createReservedWordRegex(cfg.reservedCommands, cfg.identChars)), _defineProperty(_this$REGEX_MAP, _token.TokenType.RESERVED_BINARY_COMMAND, regexFactory.createReservedWordRegex(cfg.reservedBinaryCommands, cfg.identChars)), _defineProperty(_this$REGEX_MAP, _token.TokenType.RESERVED_JOIN_CONDITION, regexFactory.createReservedWordRegex((_cfg$reservedJoinCond = cfg.reservedJoinConditions) !== null && _cfg$reservedJoinCond !== void 0 ? _cfg$reservedJoinCond : ['ON', 'USING'], cfg.identChars)), _defineProperty(_this$REGEX_MAP, _token.TokenType.OPERATOR, regexFactory.createOperatorRegex('+-/*%&|^><=.,;[]{}`:$@', ['<>', '<=', '>=', '!='].concat(_toConsumableArray((_cfg$operators = cfg.operators) !== null && _cfg$operators !== void 0 ? _cfg$operators : [])))), _defineProperty(_this$REGEX_MAP, _token.TokenType.BLOCK_START, regexFactory.createParenRegex((_cfg$blockStart = cfg.blockStart) !== null && _cfg$blockStart !== void 0 ? _cfg$blockStart : ['('])), _defineProperty(_this$REGEX_MAP, _token.TokenType.BLOCK_END, regexFactory.createParenRegex((_cfg$blockEnd = cfg.blockEnd) !== null && _cfg$blockEnd !== void 0 ? _cfg$blockEnd : [')'])), _defineProperty(_this$REGEX_MAP, _token.TokenType.RESERVED_CASE_START, /^(CA[S\u017F]E)\b/i), _defineProperty(_this$REGEX_MAP, _token.TokenType.RESERVED_CASE_END, /^(END)\b/i), _defineProperty(_this$REGEX_MAP, _token.TokenType.LINE_COMMENT, regexFactory.createLineCommentRegex((_cfg$lineCommentTypes = cfg.lineCommentTypes) !== null && _cfg$lineCommentTypes !== void 0 ? _cfg$lineCommentTypes : ['--'])), _defineProperty(_this$REGEX_MAP, _token.TokenType.BLOCK_COMMENT, /^(\/\*(?:(?![])[\s\S])*?(?:\*\/|$))/), _defineProperty(_this$REGEX_MAP, _token.TokenType.NUMBER, /^(0x[0-9A-Fa-f]+|0b[01]+|(\x2D[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)?[0-9]+(\.[0-9]*)?([Ee][\+\x2D]?[0-9]+(\.[0-9]+)?)?)/), _defineProperty(_this$REGEX_MAP, _token.TokenType.PARAMETER, NULL_REGEX), _defineProperty(_this$REGEX_MAP, _token.TokenType.EOF, NULL_REGEX), _this$REGEX_MAP);
    this.paramPatterns = this.excludePatternsWithoutRegexes([{
      // :name placeholders
      regex: regexFactory.createParameterRegex((_cfg$namedParamTypes = cfg.namedParamTypes) !== null && _cfg$namedParamTypes !== void 0 ? _cfg$namedParamTypes : [], regexFactory.createIdentPattern(cfg.paramChars || cfg.identChars)),
      parseKey: function parseKey(v) {
        return v.slice(1);
      }
    }, {
      // :"name" placeholders
      regex: regexFactory.createParameterRegex((_cfg$quotedParamTypes = cfg.quotedParamTypes) !== null && _cfg$quotedParamTypes !== void 0 ? _cfg$quotedParamTypes : [], regexFactory.createQuotePattern(cfg.identTypes)),
      parseKey: function parseKey(v) {
        return _this.getEscapedPlaceholderKey({
          key: v.slice(2, -1),
          quoteChar: v.slice(-1)
        });
      }
    }, {
      // :1, :2, :3 placeholders
      regex: regexFactory.createParameterRegex((_cfg$numberedParamTyp = cfg.numberedParamTypes) !== null && _cfg$numberedParamTyp !== void 0 ? _cfg$numberedParamTyp : [], '[0-9]+'),
      parseKey: function parseKey(v) {
        return v.slice(1);
      }
    }, {
      // ? placeholders
      regex: cfg.positionalParams ? /^(\?)/ : undefined,
      parseKey: function parseKey(v) {
        return v.slice(1);
      }
    }]);
  }

  _createClass(Tokenizer, [{
    key: "excludePatternsWithoutRegexes",
    value: function excludePatternsWithoutRegexes(patterns) {
      return patterns.filter(function (p) {
        return p.regex !== undefined;
      });
    }
    /**
     * Takes a SQL string and breaks it into tokens.
     * Each token is an object with type and value.
     *
     * @param {string} input - The SQL string
     * @returns {Token[]} output token stream
     */

  }, {
    key: "tokenize",
    value: function tokenize(input) {
      var tokens = [];
      var token; // Keep processing the string until it is empty

      while (input.length) {
        // grab any preceding whitespace
        var whitespaceBefore = this.getWhitespace(input);
        input = input.substring(whitespaceBefore.length);

        if (input.length) {
          // Get the next token and the token type
          token = this.getNextToken(input, token);

          if (!token) {
            throw new Error("Parse error: Unexpected \"".concat(input.slice(0, 100), "\""));
          } // Advance the string


          input = input.substring(token.text.length);
          tokens.push(_objectSpread(_objectSpread({}, token), {}, {
            whitespaceBefore: whitespaceBefore
          }));
        }
      }

      return this.preprocess(tokens);
    }
    /** Matches preceding whitespace if present */

  }, {
    key: "getWhitespace",
    value: function getWhitespace(input) {
      var matches = input.match(WHITESPACE_REGEX);
      return matches ? matches[1] : '';
    }
    /** Attempts to match next token from input string, tests RegExp patterns in decreasing priority */

  }, {
    key: "getNextToken",
    value: function getNextToken(input, previousToken) {
      return this.matchToken(_token.TokenType.LINE_COMMENT, input) || this.matchToken(_token.TokenType.BLOCK_COMMENT, input) || this.matchToken(_token.TokenType.STRING, input) || this.matchQuotedIdentToken(input) || this.matchToken(_token.TokenType.VARIABLE, input) || this.matchToken(_token.TokenType.BLOCK_START, input) || this.matchToken(_token.TokenType.BLOCK_END, input) || this.matchPlaceholderToken(input) || this.matchToken(_token.TokenType.NUMBER, input) || this.matchReservedWordToken(input, previousToken) || this.matchToken(_token.TokenType.IDENT, input) || this.matchToken(_token.TokenType.OPERATOR, input);
    }
    /**
     * Attempts to match a placeholder token pattern
     * @return {Token | undefined} - The placeholder token if found, otherwise undefined
     */

  }, {
    key: "matchPlaceholderToken",
    value: function matchPlaceholderToken(input) {
      var _iterator = _createForOfIteratorHelper(this.paramPatterns),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _step.value,
              regex = _step$value.regex,
              parseKey = _step$value.parseKey;
          var token = this.match({
            input: input,
            regex: regex,
            type: _token.TokenType.PARAMETER,
            transform: _utils.id
          });

          if (token) {
            return _objectSpread(_objectSpread({}, token), {}, {
              key: parseKey(token.value)
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return undefined;
    }
  }, {
    key: "getEscapedPlaceholderKey",
    value: function getEscapedPlaceholderKey(_ref) {
      var key = _ref.key,
          quoteChar = _ref.quoteChar;
      return key.replace(new RegExp((0, _utils.escapeRegExp)('\\' + quoteChar), 'gu'), quoteChar);
    }
  }, {
    key: "matchQuotedIdentToken",
    value: function matchQuotedIdentToken(input) {
      return this.match({
        input: input,
        regex: this.quotedIdentRegex,
        type: _token.TokenType.IDENT,
        transform: _utils.id
      });
    }
    /**
     * Attempts to match a Reserved word token pattern, avoiding edge cases of Reserved words within string tokens
     * @return {Token | undefined} - The Reserved word token if found, otherwise undefined
     */

  }, {
    key: "matchReservedWordToken",
    value: function matchReservedWordToken(input, previousToken) {
      // A reserved word cannot be preceded by a '.'
      // this makes it so in "mytable.from", "from" is not considered a reserved word
      if ((previousToken === null || previousToken === void 0 ? void 0 : previousToken.value) === '.') {
        return undefined;
      } // prioritised list of Reserved token types


      return this.matchReservedToken(_token.TokenType.RESERVED_CASE_START, input) || this.matchReservedToken(_token.TokenType.RESERVED_CASE_END, input) || this.matchReservedToken(_token.TokenType.RESERVED_COMMAND, input) || this.matchReservedToken(_token.TokenType.RESERVED_BINARY_COMMAND, input) || this.matchReservedToken(_token.TokenType.RESERVED_DEPENDENT_CLAUSE, input) || this.matchReservedToken(_token.TokenType.RESERVED_LOGICAL_OPERATOR, input) || this.matchReservedToken(_token.TokenType.RESERVED_KEYWORD, input) || this.matchReservedToken(_token.TokenType.RESERVED_JOIN_CONDITION, input);
    } // Helper for matching RESERVED_* tokens which need to be transformed to canonical form

  }, {
    key: "matchReservedToken",
    value: function matchReservedToken(tokenType, input) {
      return this.match({
        input: input,
        type: tokenType,
        regex: this.REGEX_MAP[tokenType],
        transform: toCanonicalKeyword
      });
    } // Shorthand for `match` that looks up regex from REGEX_MAP

  }, {
    key: "matchToken",
    value: function matchToken(tokenType, input) {
      return this.match({
        input: input,
        type: tokenType,
        regex: this.REGEX_MAP[tokenType],
        transform: _utils.id
      });
    }
    /**
     * Attempts to match RegExp from head of input, returning undefined if not found
     * @param {string} _.input - The string to match
     * @param {TokenType} _.type - The type of token to match against
     * @param {RegExp} _.regex - The regex to match
     * @return {Token | undefined} - The matched token if found, otherwise undefined
     */

  }, {
    key: "match",
    value: function match(_ref2) {
      var input = _ref2.input,
          type = _ref2.type,
          regex = _ref2.regex,
          transform = _ref2.transform;
      var matches = input.match(regex);

      if (matches) {
        return {
          type: type,
          text: matches[1],
          value: transform(matches[1])
        };
      }

      return undefined;
    }
  }]);

  return Tokenizer;
}();

exports["default"] = Tokenizer;
//# sourceMappingURL=Tokenizer.js.map
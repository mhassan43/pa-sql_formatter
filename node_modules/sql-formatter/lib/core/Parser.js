"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _token = require("./token");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * A rudimentary parser that slices token stream into list of SQL statements.
 */
var Parser = /*#__PURE__*/function () {
  function Parser(tokens) {
    _classCallCheck(this, Parser);

    this.tokens = tokens;

    _defineProperty(this, "index", 0);
  }

  _createClass(Parser, [{
    key: "parse",
    value: function parse() {
      var statements = [];
      var stat;

      while (stat = this.statement()) {
        statements.push(stat);
      }

      return statements;
    }
  }, {
    key: "statement",
    value: function statement() {
      var tokens = [];

      while (true) {
        if (this.look().value === ';') {
          tokens.push(this.next());
          return {
            type: 'statement',
            tokens: tokens
          };
        } else if (this.look().type === _token.TokenType.EOF) {
          if (tokens.length > 0) {
            return {
              type: 'statement',
              tokens: tokens
            };
          } else {
            return undefined;
          }
        } else {
          tokens.push(this.next());
        }
      }
    } // Returns current token without advancing the pointer

  }, {
    key: "look",
    value: function look() {
      return this.tokens[this.index] || _token.EOF_TOKEN;
    } // Returns current token and advances the pointer to next token

  }, {
    key: "next",
    value: function next() {
      return this.tokens[this.index++] || _token.EOF_TOKEN;
    }
  }]);

  return Parser;
}();

exports["default"] = Parser;
module.exports = exports.default;
//# sourceMappingURL=Parser.js.map